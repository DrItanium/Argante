#!/usr/bin/perl -w
#
# A2 Virtual Machine - JIT-table autogenerator
# Copyright (c) 2001	James Kehl <ecks@optusnet.com.au>
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; version 2 of the License, with the
# added restriction that it may only be converted to the version 2 of the
# GNU General Public License.
# 
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#
############################################################################
#
# While I can't see anyone linking to this Perl-script, it would get rather
# confusing if the parts of itself it printed were GPL'd, but the rest
# derived from the LGPL sources...
#

my ($in);
my (%ops, %op2, %opargs, %protflag1, %protflag2);
my $istr="usf";

# FIRST READ IN THE CODE...

while($in=<STDIN>)
{
	if ($in =~ m/\/\*\!/) {
		my ($opname, $args, $t1, $t2, $p1, $p2, $funcname);
		my @l=split(/ /, $in);

		$opname=$l[1];
		$args=$l[2];

		if (defined $opargs{$opname} && $opargs{$opname} != $args) {
			printf("<!> argcount mismatch for %s\n", $opname);
		}
		$opargs{$opname} = $args;

		if ($args >= 2) {
			$t2=$l[5];
			$p2=$l[6];
			$funcname=$l[8];
			
			if (defined $protflag2{$opname} && $protflag2{$opname} ne $p2) {
				printf("<!> protflag 2 mismatch for %s\n", $opname);
			} else { $protflag2{$opname} = $p2; }
		} else {
			$t2="u";
			$p2="RO";
			$funcname=$l[6];
		}


		if ($args >= 1) {
			$t1=$l[3];
			$p1=$l[4];

			if (defined $protflag1{$opname} && $protflag1{$opname} ne $p1) {
				printf("<!> protflag 1 mismatch for %s\n", $opname);
			} else { $protflag1{$opname} = $p1; }
		} else {
			$t1="u";
			$p1="RO";
			$funcname=$l[4];
		}

		$t1=index($istr, $t1);
		if ($t1 < 0) { printf("<!> unknown type for %s\n", $opname); }
		$t2=index($istr, $t2);
		if ($t2 < 0) { printf("<!> unknown type for %s\n", $opname); }

		$ops{$opname}=1;
		$op2{join('_', $opname, $t1 + 3*$t2)} = $funcname;
	}
}

# NOW THE FUN BEGINS...
open TABFILE, ">cmdtabs.h";
print TABFILE "/* Autogenerated, edit cmd.c instead! */\n#define NONE cmd_corrupt_bcode\n\n";

my @keysort=sort(keys %ops);

print TABFILE "jitfunc *jit_calls[] = {";

foreach $in (@keysort) {
	my $i;
	$i=0;
	while ($i<9)
	{
		my $funcname;
		$funcname=$op2{join('_', $in, $i)};
		
		if ($i % 3 == 0) { print TABFILE "\n\t"; }
		
		if (defined $funcname) {
			print TABFILE $funcname . ", ";
		} else {
			print TABFILE "NONE, ";
		}
		$i++;
	}
}
print TABFILE "\n};\n\n";

print TABFILE "const unsigned int jit_protflags[] = {\n";

my $opcount=0;
foreach $in (@keysort) {
	printf TABFILE "/* %s */\n\t", $in;
	if (defined $protflag1{$in} && $protflag1{$in} eq "RW") {
		print TABFILE "A1_READ_WRITE";
	} else {
		print TABFILE "A1_READ_ONLY";
	}
	print TABFILE " | ";

	if (defined $protflag2{$in} && $protflag2{$in} eq "RW") {
		print TABFILE "A2_READ_WRITE";
	} else {
		print TABFILE "A2_READ_ONLY";
	}
	print TABFILE ",\n";
	$opcount++;
}
print TABFILE "/* END */\n};\n\n";

close(TABFILE);

open HFILE, ">opcodes.h";
my $opnum=0;
foreach $in (@keysort) {
	printf HFILE "#define CMD_%s 0x%x\n", $in, $opnum;
	$opnum++;
}
printf HFILE "#define CMD_INVALID 0x%x\n", $opcount;
close HFILE;

open HFILE, ">cmd.h";
print HFILE "/* Autogenerated, edit autogen.pl or cmd.c instead! */\n";
print HFILE "#define A1_READ_ONLY 0x0\n#define A2_READ_ONLY 0x0\n#define A1_READ_WRITE 0x1\n#define A2_READ_WRITE 0x2\n\n";
# For NONREENTRANT kernel:
#print HFILE "#define JIT_ARGS\nextern struct vcpu *curr_cpu; extern anyval *a1; extern anyval *a2;\n#define NONREENTRANT\n";
# For REENTRANT (MT) kernel - IS FASTER!:
print HFILE "#define JIT_ARGS struct vcpu *curr_cpu, anyval *a1, anyval *a2\n";
print HFILE "typedef void jitfunc (JIT_ARGS);\n\n";
print HFILE "extern const unsigned int jit_protflags[];\nextern jitfunc *jit_calls[];\n\n";
print HFILE "#include \"opcodes.h\"\n";
close HFILE;

# OK... NOW LANG2.H
#
# New mask def's:
# The bits (1 << TYPE_UNSIGNED) indicates allowance of unsigned arg. etc.
# TYPE_UNSIGNED	000 TYPE_SIGNED	001 TYPE_FLOAT	002 */
#
# The bit (1 << TYPE_REGISTER) indicates the arg MUST be a register, ie.
# IMM's disallowed. Without it, either is OK. Of course, IMMpointers are
# still allowed...
# TYPE_REGISTER	004 */
#
# The bit (1 << TYPE_POINTER) indicates if a pointer is OK.
# TYPE_POINTER		010 */

open LANG2, ">lang2.h";

print LANG2 "/* Autogenerated, edit cmd.c instead! */\n\nstruct op_desc2 {\nchar *name;\nunsigned char bcode;\n";
print LANG2 "int params;\nint tparam1;\nint tparam2;\n};\n\n";

print LANG2 "#define OPS (sizeof(op)/sizeof(struct op_desc2))\n\n";
print LANG2 "struct op_desc2 op[] = {\n";

$opcount=0;
foreach $in (@keysort) {
	my ($t1, $t2);
	my ($i, $j);

	$t1=$t2=(1 << 010); # Any pointer is OK
	
	if (defined $protflag1{$in} && $protflag1{$in} eq "RW") {
		$t1|=(1 << 004); # Has to be writable
	}

	if (defined $protflag2{$in} && $protflag2{$in} eq "RW") {
		$t2|=(1 << 004);
	}

	$i=0;
	while ($i<3)
	{
		$j=0;
		while ($j<3)
		{
			if (defined $op2{join('_', $in, $i + $j * 3)})
			{ 
				$t1|=(1 << $i);
				$t2|=(1 << $j);
			}
			$j++;
		}

		$i++;
	}

	printf(LANG2 "{ \"%s\",\t0x%x,\t%d,\t0x%x,\t0x%x },\n", $in, $opcount, $opargs{$in}, $t1, $t2);
	$opcount++;
}

print LANG2 "};\n";
close(LANG2);
