#!/usr/bin/perl -w
#
# A2 Virtual Machine - Module autogenerator
# Copyright (c) 2001	James Kehl <ecks@optusnet.com.au>
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; version 2 of the License, with the
# added restriction that it may only be converted to the version 2 of the
# GNU General Public License.
# 
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#

# This is to autocreate the module's syscall loading
# code, and the NAGT syscall-table at the same time.
#

my ($in, $lower, $upper);
my (%names, %funcs, %sys2);
my (%tfuncs, %tsys2);

# FIRST READ IN THE CODE...


my($fn);

$fn=$ARGV[0];
# basename
my @a=split(/\//, $fn);
my $fnbase=pop(@a);
printf "Processing module %s...\n", $fnbase;

open INFILE, "<" . $fn . ".c";

#/*. SYSCALL_NAME [ID] ["SYS2"] = func_name */
while($in=<INFILE>)
{
	if ($in =~ m/\/\*\!/) {
		my ($name, $id, $func, $s2);
		my @l=split(/ /, $in);
		if ($l[1] eq "assigned") {
			$lower=$l[2];
			if ($lower =~ /^0/) { $lower=oct($lower); } else { $lower=int($lower); }
			$upper=$l[4];
			if ($upper =~ /^0/) { $upper=oct($lower); } else { $upper=int($upper); }
		} else {
			if (!defined($lower) || !defined($upper)) {
				print("<!> Warning: Syscall assigned range has not been given. Things will break\n");
				$lower=1;
				$upper=0xffffffff;
			}
			$name=$l[1];

			$s2=0;

			if ($l[2] eq "SYS2") {
				$s2=1;
				$func=$l[4];
			} elsif ($l[2] ne "=") {
				$id=$l[2];
				if ($id =~ /^0/) { $id=oct($id); } else { $id=int($id); }
				if ($l[3] eq "SYS2") {
					$s2=1;
					$func=$l[5];
				} else {
					$func=$l[4];
				}
			} else {
				$func=$l[3];
			}

			
			if (defined($id)) {
				if ($id > $upper || $id < $lower) {
					printf("<!> Syscall %s (id 0x%x) breaks assigned range\n", $name, $id);
				}
				$names{$id}=$name;
				$funcs{$id}=$func;
				$sys2{$id}=$s2;
			} else {
				printf("unid'd function %s (%d)\n", $func, $s2);
				$tfuncs{$name}=$func;
				$tsys2{$name}=$s2;
			}
		}
	}
}
close INFILE;

# Now assign SC ID's to the unnumbered ones...
my $i=$lower;

foreach $in (keys %tfuncs) {
	while (defined($names{$i})) { $i++; }
	printf("<+> Assigning id 0x%x to syscall %s... please make this permanent ASAP\n", $i, $in);
	$names{$i}=$in;
	$funcs{$i}=$tfuncs{$in};
	$sys2{$i}=$tsys2{$in};
}

# NOW THE FUN BEGINS...
my @idsort=sort {$a <=> $b} (keys %names);

open INITFILE, ">" . $fnbase .".h";
printf INITFILE "/* Autogenerated, please edit %s.c */\n", $fnbase;
print INITFILE "#include \"modload.h\"\n";
print INITFILE "#ifndef STATIC\n";
print INITFILE "int module_init\n#else\n";
printf INITFILE "int %s_init\n#endif\n", $fnbase; 
print INITFILE "(unsigned lid) {\n\tif (module_internal_init(lid)) return 1;\n";

foreach $in (@idsort) {
	printf INITFILE "\tregister_syscall(%d, %s); /* %s */\n", $in, $funcs{$in}, $names{$in};
}

print INITFILE "\treturn 0;\n}\n\n";

foreach $in (split(' ', "vcpu_start vcpu_stop")) {
print INITFILE "#ifndef STATIC\n";
printf INITFILE "void module_%s\n#else\n", $in;
printf INITFILE "void %s_%s\n#endif\n", $fnbase, $in; 
printf INITFILE "(struct vcpu *cpu) { module_internal_%s(cpu); }\n\n", $in;
}

print INITFILE "#ifndef STATIC\n";
print INITFILE "void module_shutdown\n#else\n";
printf INITFILE "void %s_shutdown\n#endif\n", $fnbase; 
print INITFILE "() {\n\tmodule_internal_shutdown();";

foreach $in (@idsort) {
	printf INITFILE "\tunregister_syscall(%d); /* %s */\n", $in, $funcs{$in}, $names{$in};
}

print INITFILE "}\n\n";

# Add a symbol for reload
print INITFILE "#ifndef STATIC\n#ifdef MODULE_RELOAD_VER\n";
print INITFILE "int module_reload_ver=MODULE_RELOAD_VER;\n";
print INITFILE "#endif\n#endif\n";

close INITFILE;

open TABFILE, ">" . $fnbase . ".sc";
printf TABFILE "/* from %s */\n", $fnbase;

foreach $in (@idsort) {
	printf TABFILE "{ \"%s\",\t0x%x,\t%d },\n", $names{$in}, $in, $sys2{$in};
}
close TABFILE;
