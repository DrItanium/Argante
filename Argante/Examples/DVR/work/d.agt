# zmienne globalne ... i delfiny
!SIGNATURE "Distributed Virtual Router 0.1b"
!DOMAINS 1 2 3
!PRIORITY 40000

.define DOMAIN_FILE 1
.define DOMAIN_IPC 2
.define DOMAIN_LOW 3
.define DOMAIN_NONE 0

.define FS_FLAG_READ 2
.define CONFIG_ERROR_EXCEPTION 1
.define IPC_FLAG_NONBLOCK 1
.define DVR_IPCREG	101
.define IPC_EOK		1
.define IPC_STAT_ERROR	-1
.define IPC_STAT_WAITING 0
.define IPC_STAT_COMPLETED 2

.define HOW_MANY_PACKETS_WE_NEED	512
.define HOW_MANY_ROUTE_WE_NEED 255

.define PACKET_TOO_OLD 3000000	# 3 sec. 
.define ROUTE_TOO_OLD 60000000	# 60 sec.

.define ROUTE_FLAG_UNUSED 0
.define ROUTE_FLAG_REQ 1
.define ROUTE_FLAG_STREAM 2

.DATA
:my_ip
    0
:my_netaddr
    0
:my_netmask
    0
:interface_name
    0 repeat 3
:config_filename
    "/fs/dvr/dvr.conf"
:endianess_current
    0
:in_packet_first
    0
:in_packet_last
    0
:out_packet_first
    0
:out_packet_last
    0
:packet_free
    0
:debug_t1
    0
:debug_t2
    0





.CODE
:main
    call :historical_reason
    call :endianess
    mov u0,DOMAIN_FILE
    syscall $ACCESS_SETDOMAIN
    call :read_config
    call :packet_init
    call :route_init
    mov u0,DOMAIN_LOW
    syscall $ACCESS_SETDOMAIN
    call :init_ether_le
    mov u0,DOMAIN_IPC
    syscall $ACCESS_SETDOMAIN
    call :ipc_init
    call :advertize
:main_loop
    # read packets, send route requests if needed and put them in queue
    mov u0,DOMAIN_LOW
    syscall $ACCESS_SETDOMAIN
    call :in_network_handler	
	# recive stream requests ... you know for the kids...
    mov u0,DOMAIN_IPC
    syscall $ACCESS_SETDOMAIN
    call :ipc_stream_requests_handler
	# recive route requests and route responses, create route entries
    call :recive_msg
	# timeout route entries, create streams, send/recive packets
	# enqueue them for sending
    call :route_handler
	# send packets from :out_packet_first queue
    mov u0,DOMAIN_LOW
    syscall $ACCESS_SETDOMAIN
    call :send_packets
	# timeout packets
    mov u0,DOMAIN_IPC
    syscall $ACCESS_SETDOMAIN
    call :in_packet_timeouter
	# timeout packets
    call :out_packet_timeouter
    jmp :main_loop
    halt


.DATA
:hello_world
    "Starting DVR ver. 0.1b\n[Historical] Hello world!\n"
.CODE
:historical_reason
    mov u0,:hello_world
    mov u1,^hello_world
    syscall $IO_PUTSTRING
    ret 1

    # config parser...
# DONE


.DATA
:config_error
    "Error while processing config file: "
:config_fd
    0
:config_buffer
    0
:config_file_len
    0
:config_memblock
    0
:ptr
    0
:offset
    0

    
.CODE

:onerror_config
    mov u0,:config_error
    mov u1,^config_error
    syscall $IO_PUTSTRING
    mov u0,:config_filename
    mov u1,^config_filename
    syscall $IO_PUTSTRING
    mov u0,10
    syscall $IO_PUTCHAR
    halt     

:read_config
    onfail :onerror_config
    mov u0,:config_filename
    mov u1,^config_filename
    syscall $FS_STAT
    ifneq u1,1
    raise CONFIG_ERROR_EXCEPTION
    ifabo u1,1024		# too large file ... 
    raise CONFIG_ERROR_EXCEPTION
    mov *:config_file_len,u2
    add u2,3
    div u2,4
    alloc u2,3			# read and write access  
    mov *:config_memblock,u0
    mov *:ptr,u1
    mov *:config_buffer,u1
    mov u0,:config_filename
    mov u1,^config_filename
    mov u2,FS_FLAG_READ
    syscall $FS_OPEN_FILE
    mov *:config_fd,s0
    mov u0,*:config_fd
    mov u1,*:config_buffer
    mov u2,*:config_file_len
    syscall $FS_READ_FILE
    mov u15,*:config_file_len

    mov u0,*:ptr
    mov u1,*:offset
    mov u2,32
    mov u3,u15
    syscall $MEM_STRCHR
    ifeq u2,0
    raise 1
    sub u0,*:ptr
    mul u0,4
    add u0,u1
    sub u0,*:offset
    ifeq u0,0
    raise 1
    ifabo u0,12
    raise 1
    mov u10,u0
    mov u0,:interface_name
    mov u1,0
    mov u2,*:ptr
    mov u3,0
    mov u4,u10
    syscall $MEM_STRCPY
    add u10,1
    sub u15,u10      
    add *:offset,u10


    mov u0,*:ptr
    mov u1,*:offset
    mov u2,u15
    syscall $MEM_STRTOINT
    mov u1,1
    mov u14,u0
    ifabo u0,9
    add u1,1
    ifabo u0,99
    add u1,1
    ifabo u0,255
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,u1
    sub u15,u1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,0x2e
    mov u3,1
    syscall $MEM_STRCHR
    ifeq u2,0
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,1
    sub u15,1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,u15
    syscall $MEM_STRTOINT
    mov u1,1
    mul u14,256
    add u14,u0
    ifabo u0,9
    add u1,1
    ifabo u0,99
    add u1,1
    ifabo u0,255
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,u1
    sub u15,u1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,0x2e
    mov u3,1
    syscall $MEM_STRCHR
    ifeq u2,0
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,1
    sub u15,1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,u15
    syscall $MEM_STRTOINT
    mov u1,1
    mul u14,256
    add u14,u0
    ifabo u0,9
    add u1,1
    ifabo u0,99
    add u1,1
    ifabo u0,255
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,u1
    sub u15,u1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,0x2e
    mov u3,1
    syscall $MEM_STRCHR
    ifeq u2,0
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,1
    sub u15,1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,u15
    syscall $MEM_STRTOINT
    mov u1,1
    mul u14,256
    add u14,u0
    ifabo u0,9
    add u1,1
    ifabo u0,99
    add u1,1
    ifabo u0,255
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,u1
    sub u15,u1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,0x2f
    mov u3,1
    syscall $MEM_STRCHR
    ifeq u2,0
    raise CONFIG_ERROR_EXCEPTION
    add *:offset,1
    sub u15,1
    mov u0,*:ptr
    mov u1,*:offset
    mov u2,u15
    syscall $MEM_STRTOINT
    mov u13,u0
    ifabo u0,32
    raise CONFIG_ERROR_EXCEPTION
    mov u0,0xffffffff
    mov u1,32
    sub u1,u13
:mask_loop
    ifeq u1,0
    jmp :mask_out_loop
    mul u0,2
    sub u1,1
    jmp :mask_loop
:mask_out_loop
    mov *:my_netmask,u0
    mov *:my_ip,u14
    and u14,u0
    mov *:my_netaddr,u14
    dealloc *:config_memblock
    mov u0,*:config_fd
    syscall $FS_CLOSE_FILE
    nofail
    ret 1

    # packet queue
# seems like done

# packet_bucket structure:
# (0) prev
# (1) next
# (2) t_sec
# (3) t_usec
# (4) len
# (5) d_addr
# (6) netlen
# (7) data
# sizeof packet_bucket = 375 + 7 = 382 dwordy

.define PCKT_SIZEOF 382

.DATA
:packet_dummy
    0
.CODE

########################################################################
# packet_init in () out () changes (u0123)

:packet_init
    mov u3,HOW_MANY_PACKETS_WE_NEED
    mov u0,PCKT_SIZEOF
    mul u0,u3
    alloc u0,3			# allow read & write
    mov *:packet_free,u1
:packet_init_loopa    
    mov u2,u1
    add u2,1
    add u1,PCKT_SIZEOF
    mov *u2,u1
    sub u3,1
    ifneq u3,0
    jmp :packet_init_loopa    
    mov *u2,0
    ret 1


#########################################################################
# packet_new in () out (u0) changes ()

.DATA
:packet_temp
    0
:packet_temp2
    0
:packet_temp3
    0
:packet_new_1
    " -- in packet new _ before "
:packet_new_2
    " -- in packet new _ after "
.CODE
:packet_new
# debug
#    mov s15,:packet_new_1
#    mov s14,^packet_new_1
#    mov s13,*:packet_free
#    call :debug_int
# e o d
    mov u0,*:packet_free
    ifeq u0,0
    ret 1
    mov *:packet_temp,u1
    mov *u0,0
    mov u1,u0
    add u1,1
    mov *:packet_free,*u1
    mov *u1,0
    mov u1,*:packet_temp
# debug
#    mov s15,:packet_new_2
#    mov s14,^packet_new_2
#    mov s13,*:packet_free
#    call :debug_int
# e o d
    ret 1

#########################################################################
# packet_done in (u0) out () changes ()
.DATA
:packet_done_1
    " -- in packet done _ before "
:packet_done_2
    " -- in packet done _ after "
.CODE

:packet_done
# debug
#    mov s15,:packet_done_1
#    mov s14,^packet_done_1
#    mov s13,*:packet_free
#    call :debug_int
# e o d
    mov *:packet_temp,u1
    mov *u0,0
    mov u1,u0
    add u1,1
    mov *u1,*:packet_free
    mov u1,*:packet_temp
    mov *:packet_free,u0
# debug
#    mov s15,:packet_done_2
#    mov s14,^packet_done_2
#    mov s13,*:packet_free
#    call :debug_int
# e o d
    ret 1

#########################################################################
# packet_in_unlink in (u0) out () changes ()

:packet_in_unlink
    mov *:packet_temp,u1
    mov *:packet_temp2,u2
    mov u1,u0
    add u1,1
    ifeq *u0,0
    jmp :packet_in_unlink1
    mov u2,*u0
    add u2,1 
    mov *u2,*u1
    jmp :packet_in_unlink2
:packet_in_unlink1
    mov *:in_packet_first,*u1
:packet_in_unlink2
    ifeq *u1,0
    jmp :packet_in_unlink3
    mov u2,*u1
    mov *u2,*u0
    jmp :packet_in_unlink4
:packet_in_unlink3
    mov *:in_packet_last,*u0
:packet_in_unlink4
    mov *u0,0
    mov *u1,0
    mov u1,*:packet_temp
    mov u2,*:packet_temp2
    ret 1

#########################################################################
# packet_in_link in (u0) out () changes ()

:packet_in_link
    ifeq *:in_packet_first,0
    jmp :packet_in_link_simple
    mov *:packet_temp,u1
    mov u1,*:in_packet_last
    mov *u0,u1
    add u1,1
    mov *u1,u0
    mov *:in_packet_last,u0
    mov u1,*:packet_temp
    ret 1
:packet_in_link_simple
    mov *:in_packet_first,u0
    mov *:in_packet_last,u0
    ret 1        

#########################################################################
# packet_out_unlink in (u0) out () changes ()

:packet_out_unlink
    mov *:packet_temp,u1
    mov *:packet_temp2,u2
    mov u1,u0
    add u1,1
    ifeq *u0,0
    jmp :packet_out_unlink1
    mov u2,*u0
    add u2,1
    mov *u2,*u1
    jmp :packet_out_unlink2
:packet_out_unlink1
    mov *:out_packet_first,*u1
:packet_out_unlink2
    ifeq *u1,0
    jmp :packet_out_unlink3
    mov u2,*u1
    mov *u2,*u0
    jmp :packet_out_unlink4
:packet_out_unlink3
    mov *:out_packet_last,*u0
:packet_out_unlink4
    mov *u0,0
    mov *u1,0
    mov u1,*:packet_temp
    mov u2,*:packet_temp2
    ret 1

#########################################################################
# packet_out_link in (u0) out () changes ()

:packet_out_link
    ifeq *:out_packet_first,0
    jmp :packet_out_link_simple
    mov *:packet_temp,u1
    mov u1,*:out_packet_last
    mov *u0,u1
    add u1,1
    mov *u1,u0
    mov *:out_packet_last,u0
    mov u1,*:packet_temp
    ret 1
:packet_out_link_simple
    mov *:out_packet_first,u0
    mov *:out_packet_last,u0
    ret 1        

###########################################################################
# find_packet_to in (u0,u1) out (u0) change ()

.DATA
:find_packet_to_temp
    0
:find_packet_to_temp2
    0
:fpt_1
    0
:fpt_2
    0
.CODE
:find_packet_to
    mov *:find_packet_to_temp,u2
    mov *:find_packet_to_temp2,u3
    mov u2,*:in_packet_first
    ifeq u2,0
    jmp :find_packet_to_done
:find_packet_to_loopa
    mov u3,u2
    add u3,5
    mov u3,*u3
    and u3,u1
    ifeq u3,u0
    jmp :find_packet_to_done
    add u2,1
    mov u2,*u2
    ifneq u2,0
    jmp :find_packet_to_loopa
:find_packet_to_done
    mov u0,u2
    mov u2,*:find_packet_to_temp
    mov u3,*:find_packet_to_temp2
    ret 1


############################################################################
# out/in_packet_timeouter in () out () change (a lot)
.DATA
:packet_timeouter_debug
    "-- done with packet\n"
.CODE
:in_packet_timeouter
    mov u0,*:in_packet_first
    ifeq u0,0
    ret 1
:in_packet_timeouter_loopa
    mov u10,u0
    add u10,1
    mov u10,*u10
    call :count_age
    ifbel u1,PACKET_TOO_OLD
    jmp :in_packet_timeouter_nextone
    call :packet_in_unlink
    call :packet_done
# debug
#    mov s15,:packet_timeouter_debug
#    mov s14,^packet_timeouter_debug
#    call :debug
# eod
:in_packet_timeouter_nextone
    mov u0,u10
    ifneq u0,0
    jmp :in_packet_timeouter_loopa
    ret 1

:out_packet_timeouter
    mov u0,*:out_packet_first
    ifeq u0,0
    ret 1
:out_packet_timeouter_loopa
    mov u10,u0
    add u10,1
    mov u10,*u10
    call :count_age
    ifbel u1,PACKET_TOO_OLD
    jmp :out_packet_timeouter_nextone
    call :packet_out_unlink
    call :packet_done
:out_packet_timeouter_nextone
    mov u0,u10
    ifneq u0,0
    jmp :out_packet_timeouter_loopa
    ret 1

# timestamp functions
# DONE

.DATA
:time_temp
    0
:time_temp2
    0
:time_temp3
    0
.CODE

###########################################################################
# touch_packet in (u0) out () change ()

:touch_structure
    mov *:time_temp,u0
    mov *:time_temp2,u1
    mov *:time_temp3,u2
    mov u2,u0
    syscall $LOCAL_GETTIME
    add u2,2
    mov *u2,u0
    add u2,1
    mov *u2,u1
    mov u0,*:time_temp
    mov u1,*:time_temp2
    mov u2,*:time_temp3
    ret 1
    
###########################################################################
# count_age in (u0) out (u1) change ()

:count_age
    mov *:time_temp,u0
    mov *:time_temp2,u2
    mov u2,u0
    add u2,2
    syscall $LOCAL_GETTIME
    sub u0,*u2
    add u2,1
    sub u1,*u2
    mul u0,1000000
    add u1,u0
    mov u0,*:time_temp
    mov u2,*:time_temp2
    ret 1


:debug
    mov *:debug_t1,u0
    mov *:debug_t2,u1
    syscall $LOCAL_GETTIME
    syscall $IO_PUTINT
    mov u0,32
    syscall $IO_PUTCHAR
    mov u0,u1
    syscall $IO_PUTINT
    mov u0,32
    syscall $IO_PUTCHAR
    mov u0,s15
    mov u1,s14
    syscall $IO_PUTSTRING
    mov u0,*:debug_t1
    mov u1,*:debug_t2
    ret 1

:debug_int
    mov *:debug_t1,u0
    mov *:debug_t2,u1
    syscall $LOCAL_GETTIME
    syscall $IO_PUTINT
    mov u0,32
    syscall $IO_PUTCHAR
    mov u0,u1
    syscall $IO_PUTINT
    mov u0,32
    syscall $IO_PUTCHAR
    mov u0,s15
    mov u1,s14
    syscall $IO_PUTSTRING
    mov u0,s13
    syscall $IO_PUTINT
    mov u0,10
    syscall $IO_PUTCHAR
    mov u0,*:debug_t1
    mov u1,*:debug_t2
    ret 1
        
# almost done 

# route entry
# (0) prev
# (1) next 
# (2) t_sec
# (3) t_usec
# (4) netaddr
# (5) netmask
# (6) vcpu
# (7) vs
# (8) flags		0 / 1 / 2
# (9) req_id
# (10) stream
# (11) in_packet
# (12) in_ptr
# (13) in_len
# (14) out_packet
# (15) out_ptr
# (16) out_len

.define ROUTE_SIZEOF 17

.DATA
:route_entries
    0
:route_free
    0
:route_temp
    0
:route_temp2
    0
.CODE

#########################################################################
# route_init in () out () change (a lot)

:route_init
    mov u3,HOW_MANY_ROUTE_WE_NEED
    mov u0,ROUTE_SIZEOF
    mul u0,u3
    alloc u0,3
    mov *:route_free,u1
:route_init_loopa    
    mov u2,u1
    add u2,1
    add u1,ROUTE_SIZEOF
    mov *u2,u1
    sub u3,1
    ifneq u3,0
    jmp :route_init_loopa    
    mov *u2,0
    ret 1


#########################################################################
# route_new in () out (u0) change ()

.DATA
:rn_1
    "-- in route new _ before: "
:rn_2
    "-- in route new _ after: "
.CODE
:route_new
# debug
#    mov s15,:rn_1
#    mov s14,^rn_1
#    mov s13,*:route_free
#    call :debug_int
# e o d
    mov u0,*:route_free
    ifeq u0,0
    ret 1
    mov *:route_temp,u1
    mov u1,u0
    add u1,1
    mov *:route_free,*u1
    mov *u1,0
    mov u1,*:route_temp
# debug
#    mov s15,:rn_2
#    mov s14,^rn_2
#    mov s13,*:route_free
#    call :debug_int
# e o d
    ret 1

#########################################################################
# route_done in (u0) out () change ()
.DATA
:rdone_1
    "-- in route done _ before : "
:rdone_2
    "-- in route done _ before : "
.CODE
:route_done
# debug
#    mov s15,:rdone_1
#    mov s14,^rdone_1
#    mov s13,*:route_free
#    call :debug_int
# e o d
    mov *:route_temp,u1
    mov *u0,0
    mov u1,u0
    add u1,1
    mov *u1,*:route_free
    mov *:route_free,u0
    mov u1,*:route_temp
# debug
#    mov s15,:rdone_2
#    mov s14,^rdone_2
#    mov s13,*:route_free
#    call :debug_int
# e o d
    ret 1

#########################################################################
# route_unlink in (u0) out () change ()

.DATA
:runlink_1
    "-- in route unlink _ before: "
:runlink_2
    "-- in route unlink _ after: "

.CODE

:route_unlink    
# debug
#    mov s15,:runlink_1
#    mov s14,^runlink_1
#    mov s13,*:route_entries
#    call :debug_int
# e o d
    mov *:route_temp,u1
    mov *:route_temp2,u2
    mov u1,u0
    add u1,1
    ifeq *u0,0
    jmp :route_unlink1
    mov u2,*u0
    add u2,1
    mov *u2,*u1
    jmp :route_unlink2
:route_unlink1
    mov *:route_entries,*u1
:route_unlink2        
    ifeq *u1,0
    jmp :route_unlink3
    mov u2,*u1
    mov *u2,*u0
:route_unlink3
    mov *u1,0
    mov *u0,0
    mov u1,*:route_temp
    mov u2,*:route_temp2
# debug
#    mov s15,:runlink_2
#    mov s14,^runlink_2
#    mov s13,*:route_entries
#    call :debug_int
# e o d
    ret 1

#########################################################################
# route_link in (u0) out () change ()

.DATA
:rlink_1
    "-- in route link _ before: "
:rlink_2
    "-- in route link _ after: "

.CODE
:route_link
# debug
#    mov s15,:rlink_1
#    mov s14,^rlink_1
#    mov s13,*:route_entries
#    call :debug_int
# e o d
    mov *:route_temp,u0
    mov *:route_temp2,u1
    mov u1,*:route_entries
    mov *:route_entries,u0
    mov *u1,u0
    mov *u0,0
    add u0,1
    mov *u0,u1
    mov u0,*:route_temp
    mov u1,*:route_temp2
# debug
#    mov s15,:rlink_2
#    mov s14,^rlink_2
#    mov s13,*:route_entries
#    call :debug_int
# e o d
    ret 1    

#########################################################################
# route_find in (u14) out (u0) change ()

:route_find
    mov u0,*:route_entries
    ifeq u0,0
    ret 1
    mov *:route_temp,u1
    mov *:route_temp2,u2
:route_find_loopa
    mov u1,u0
    add u1,5
    mov u2,*u1
    ifeq u2,0
    jmp :route_find_reloop
    and u2,u14
    sub u1,1
    ifeq u2,*u1
    jmp :route_find_outa
:route_find_reloop
    add u0,1
    mov u0,*u0
    ifneq u0,0
    jmp :route_find_loopa
:route_find_outa
    mov u1,*:route_temp
    mov u2,*:route_temp2
    ret 1

###########################################################################
# route_find_target in (u0 u1) out (u0) change ()

:route_find_target
    mov *:route_temp,u2
    mov *:route_temp2,u3
    mov u2,u0
    mov u0,*:route_entries
    ifneq u0,0
    jmp :route_find_target_loopa
    mov u2,*:route_temp
    ret 1
:route_find_target_loopa
    mov u3,u0
    add u3,6
    ifneq *u3,u2
    jmp :route_find_target_jmp
    add u3,1
    ifneq *u3,u1
    jmp :route_find_target_jmp
    mov u2,*:route_temp
    mov u3,*:route_temp2
    ret 1
:route_find_target_jmp
    add u0,1
    mov u0,*u0
    ifneq u0,0
    jmp :route_find_target_loopa
    mov u2,*:route_temp
    mov u3,*:route_temp2
    ret 1

#########################################################################
# route_destory in (u0) out () change (u0)
.DATA
:route_destroy_temp
    0
:route_destroy_temp2
    0
:rd_1
    "-- in route_destroy\n"
:rd_2
    "-- out of route_destroy\n"
:rd_3
    "-- killing packet 1 "
:rd_4
    "-- killing packet 2 "


.CODE
:route_destroy
    mov *:route_destroy_temp,u1
    mov *:route_destroy_temp2,u2

#debug stuff
#    mov s15,:rd_1
#    mov s14,^rd_1
#    call :debug
#end of debug stuff

    mov u1,u0
    mov u2,u0
    add u1,8			# flags
    ifneq *u1,ROUTE_FLAG_STREAM	# jest stream
    jmp :route_destroy_free
    add u1,2
    mov u0,*u1
    onfail :onfail_route_destroy
    syscall $IPC_STREAM_CLOSE
    nofail
    add u1,1
#debug stuff
#    mov s15,:rd_3
#    mov s14,^rd_3
#    mov s13,*u1
#    call :debug_int
#end of debug stuff
    ifeq *u1,0
    jmp :route_destroy_no_in
    mov u0,*u1
    call :packet_done
    mov *u1,0
:route_destroy_no_in
    add u1,3
#debug stuff
#    mov s15,:rd_4
#    mov s14,^rd_4
#    mov s13,*u1
#    call :debug_int
#end of debug stuff
    ifeq *u1,0
    jmp :route_destroy_free
    mov u0,*u1
    call :packet_done
    mov *u1,0
:route_destroy_free
    mov u0,u2
    call :route_unlink
    call :route_done
#debug stuff
#    mov s15,:rd_2
#    mov s14,^rd_2
#    call :debug
#end of debug stuff
    mov u1,*:route_destroy_temp
    mov u2,*:route_destroy_temp2
    ret 1

:onfail_route_destroy
    ret 1


##########################################################################
# route_handler in () out () change (a lot)
.DATA
:route_handler_temp
    0
.CODE
:route_handler
    mov u0,*:route_entries
    ifeq u0,0
    ret 1
:route_handler_loopa
    mov u15,0
    mov u14,u0
    mov u2,u0
    add u2,1
    mov *:route_handler_temp,*u2
    call :count_age
    ifabo u1,ROUTE_TOO_OLD
    jmp :route_handler_destroy
    mov u0,u14				# not too old ;)
    mov u1,u14
    add u1,8
    ifeq *u1,ROUTE_FLAG_STREAM
    jmp :route_handler_stream_check
    ifneq *u1,ROUTE_FLAG_REQ
    jmp :route_handler_nextone		# stream not ready
    call :route_check_req_status	# check stream request status
    ifneq u1,1
    jmp :route_handler_nextone
:route_handler_stream_check
    call :write_while_can		# write while you can
    ifeq u0,0
    jmp :route_handler_nextone
    call :read_while_can		# read while you can
    ifeq u0,0
    jmp :route_handler_nextone
    ifneq u15,1
    jmp :route_handler_nextone
    call :touch_structure		# timestamp structure if needed
    jmp :route_handler_nextone
:route_handler_destroy
    call :route_destroy
:route_handler_nextone
    mov u0,*:route_handler_temp
    ifneq u0,0
    jmp :route_handler_loopa
    ret 1


#########################################################################
# route_check_req_status in (u0) out (u1) change (a lot but who cares?)
.DATA
:route_check_req_status_warning
    "[Warning] We've just lost stream request...\n"
:route_check_debug
    "--- Our stream request has been accepted\n"
.CODE
:route_check_req_status
    mov u11,u0
    add u0,9
    mov u0,*u0
    onfail :onfail_route_check_req_status
    syscall $IPC_STREAM_STAT
    nofail
    ifeq s0,IPC_STAT_WAITING
    jmp :route_check_req_status_notready
    ifeq s0,IPC_STAT_ERROR
    jmp :route_check_req_status_error
    mov u1,u11
    add u1,8
    mov *u1,ROUTE_FLAG_STREAM	# flags 2
    add u1,1
    mov *u1,0			# clear req_id
    add u1,1
    mov *u1,u3			# stream_id ->
    add u1,1
    mov *u1,0			# clear in_packet
    add u1,3
    mov *u1,0			# clear out_packet
# debug 
#    mov s15,:route_check_debug
#    mov s14,^route_check_debug
#    call :debug
# e o d 
    mov u0,u11
    mov u1,1
    ret 1
:route_check_req_status_error
    mov u0,u11
    call :route_destroy
:route_check_req_status_notready
    mov u1,0
    ret 1    

:onfail_route_check_req_status
    mov u1,:route_check_req_status_warning
    mov u2,^route_check_req_status_warning
    syscall $IO_PUTSTRING
    mov s0,IPC_STAT_ERROR
    ret 1

###########################################################################
# route_read_while_can	in (u0,u15) out(u0,u15) change (a lot)
# route_write_while_can	in (u0,u15) out(u0,u15) change (a lot)

.DATA
:iobuffer
    0 repeat 375
:rwc_temp
    0
:rwc_1
    "--- Reading new packet.\n"
:rwc_2
    "--- Read whole packet.\n"
:wwc_1
    "--- Writing new packet.\n"

.CODE

:read_while_can
    mov u14,u0
:read_while_can_loopa
    add u0,10
    mov u0,*u0
    onfail :ignore
    syscall $IPC_STREAM_INFO
    nofail
    ifeq s0,-1
    jmp :read_while_can_destroy
    mov u1,u0
    and u0,0x1
    ifeq u0,0
    jmp :read_while_can_nodata
#debug stuff
#    mov s15,:rwc_1
#    mov s14,^rwc_1
#    call :debug
#end of debug stuff
    mov u1,u14
    add u1,14
    ifneq *u1,0
    jmp :read_while_can_fillup
    call :packet_new
    ifeq u0,0
    jmp :read_while_can_done
    mov *u1,u0				# out_packet = new packet
    add u1,1
    mov *u1,0				# ptr = 0
    add u1,1
    mov *u1,4				# len = 4  (we gotta read len)
    sub u1,2
:read_while_can_fillup
    mov u10,u14
    add u10,16				
    mov u8,u10				# u8 = len
    sub u10,1
    mov u9,u10				# u9 = ptr
    sub u10,1				# u10 = packet

    sub u1,4
    mov u0,*u1		
    add u1,6
    mov u2,*u1
    mov u1,:iobuffer
    mov u3,IPC_FLAG_NONBLOCK
    onfail :ignore			# must have some data
    syscall $IPC_STREAM_READ		# so we can safely overwrite s0
    nofail				# on error
    ifeq s0,-1
    jmp :read_while_can_destroy
    mov u11,u0
    ifeq u0,0
    jmp :read_while_can_done
    mov u15,1

# debug 
#.DATA
#:before_strcpy
#    "--- before strcpy\n"
#.CODE
#    mov s15,:before_strcpy
#    mov s14,^before_strcpy
#    call :debug
# e o d 
    
    mov u0,*u10
    add u0,6
    mov u1,*u9
    mov u2,:iobuffer
    mov u3,0
    mov u4,u11
    syscall $MEM_STRCPY		# copy copy, die on any error
    
    sub *u8,u11
    add *u9,u11
    ifneq *u8,0
    jmp :read_while_can_done
    ifneq *u9,4
    jmp :read_while_can_wholepacket
    mov u0,*u10
    add u0,6
    mov u0,*u0
    call :bswab_le		# getting packet len in netorder
    ifabo u0,1500
    jmp :read_while_can_destroy	# too long stream.. over 1500 B!
    mov *u8,u0			# set new length
    mov u0,u14
    jmp :read_while_can_loopa	# and retry
:read_while_can_wholepacket
#debug stuff
#    mov s15,:rwc_2
#    mov s14,^rwc_2
#    call :debug
#end of debug stuff
    mov u0,*u10
    mov *u10,0
    call :packet_out_link
    mov u0,u14
    jmp :read_while_can_loopa		# relink packet and repeat
:read_while_can_nodata
    and u1,0x4
    ifeq u1,0
    jmp :read_while_can_done
:read_while_can_destroy
    mov u0,u14
    call :route_destroy
    mov u0,0
    mov u15,0
    ret 1
:read_while_can_done
    mov u0,u14
    ret 1




:write_while_can
    mov u14,u0
:write_while_can_loopa
    mov u0,u14
    add u0,10
    mov u0,*u0
    onfail :ignore
    syscall $IPC_STREAM_INFO
    nofail
    ifeq s0,-1
    jmp :write_while_can_dead
    mov u1,u0
    and u1,0x4
    ifeq u1,0x4
    jmp :write_while_can_dead
    mov u1,u0
    and u1,0x2
    ifneq u1,0x2
    jmp :write_while_can_done
    mov u0,u14
    add u0,10
    mov u11,*u0
    add u0,1
    mov u10,u0
    add u0,1
    mov u9,u0
    add u0,1
    mov u8,u0
    ifneq *u10,0
    jmp :write_while_can_send
    # find a new bucket to send
    mov u0,u14
    add u0,5
    mov u1,*u0
    sub u0,1
    mov u0,*u0
    ifeq u1,0
    jmp :write_while_can_done
    call :find_packet_to
    ifeq u0,0
    jmp :write_while_can_done
    call :packet_in_unlink
#debug stuff
#    mov s15,:wwc_1
#    mov s14,^wwc_1
#    call :debug
#end of debug stuff
    mov *u10,u0
    add u0,4
    mov *u8,*u0
    mov *u9,0
    
:write_while_can_send
    mov u0,:iobuffer
    mov u1,0
    mov u2,*u10
    add u2,6
    mov u3,*u9
    mov u4,*u8
    syscall $MEM_STRCPY			# copy copy
    
    mov u0,u11
    mov u1,:iobuffer
    mov u2,*u8
    mov u3,IPC_FLAG_NONBLOCK
    onfail :ignore			# must have space .. s0 is unused
    syscall $IPC_STREAM_WRITE
    nofail
    ifeq s0,-1
    jmp :write_while_can_dead
    mov u15,1
    add *u9,u0
    sub *u8,u0
    ifneq *u8,0
    jmp :write_while_can_done		# not whole packet..
    mov u0,*u10
    mov *u10,0
    call :packet_done
    jmp :write_while_can_loopa

:write_while_can_dead
    mov u0,u14
    call :route_destroy
    mov u0,0
    mov u15,0
    ret 1
:write_while_can_done
    mov u0,u14
    ret 1
# DONE

.DATA
:msg_temp
    0
:msg_temp2
    0
:msg_temp3
    0
:msg_temp4
    0
:msg_temp5
    0
:msg_temp6
    0

:send_route_request_warning
    "[Warning] Couldn't send route request.\n"
:recive_msg_route_request_warning
    "[Warning] Couldn't send route response.\n"
:recive_msg_route_response_warning
    "[Warning] Route entry mismatch.\n"
:send_stream_request_warning
    "[Warning] Couldn't establish stream connection.\n"

.CODE

###########################################################################
# advertize 
:advertize
    mov u0,IPC_FLAG_NONBLOCK
    mov s0,-1
    mov s1,-1
    mov u1,DVR_IPCREG
    mov u2,*:my_netaddr
    mov u3,*:my_netmask
    onfail :ignore
    syscall $IPC_MSG_SEND
    nofail
    ret 1

###########################################################################
# send_route_request in (u14) out () change ()

.DATA
:srr_1
    "-- Sent route request\n"
:srr_2
    "-- Sending route request\n"
.CODE

:send_route_request
# debug
#    mov s15,:srr_2
#    mov s14,^srr_2
#    call :debug
# e o d
    mov *:msg_temp,u0
    mov *:msg_temp2,u1
    mov *:msg_temp3,u2
    mov *:msg_temp4,u3
    mov *:msg_temp5,s0
    mov *:msg_temp6,s1
    mov u0,DOMAIN_IPC
    syscall $ACCESS_SETDOMAIN
    mov u0,IPC_FLAG_NONBLOCK
    mov s0,-1
    mov s1,-1
    mov u1,DVR_IPCREG
    mov u2,u14
    mov u3,0
    onfail :onfail_send_route_request
    syscall $IPC_MSG_SEND		# and we don't care about
    nofail				# status... timouter's work again
# debug
#    mov s15,:srr_1
#    mov s14,^srr_1
#    call :debug
# e o d
    mov u0,DOMAIN_LOW
    syscall $ACCESS_SETDOMAIN
    mov u0,*:msg_temp
    mov u1,*:msg_temp2
    mov u2,*:msg_temp3
    mov u3,*:msg_temp4
    mov s0,*:msg_temp5
    mov s1,*:msg_temp6
    ret 1

:onfail_send_route_request
    mov u0,:send_route_request_warning
    mov u1,^send_route_request_warning
    syscall $IO_PUTSTRING
    ret 1		# well, we ignore this error, timeouter
			# will do it's job later...


###########################################################################
# recive_msg in () out () change (a lot)

.DATA
:rr_1
    "--- Got route response\n"
:rr_2
    "--- Got route request\n"
:rr_3
    "--- Sent route response\n"
:rr_4
    "--- Got msg\n"
:rr_5
    "--- Hmm new route\n"
:rr_6
    "--- New route identification\n"

.CODE
:recive_msg
    mov u0,IPC_FLAG_NONBLOCK
    syscall $IPC_MSG_RECV		# die on any error
    ifneq s0,IPC_EOK
    ret 1
# debug stuff
#    mov s15,:rr_4
#    mov s14,^rr_4
#    call :debug
# e o d
    ifeq u4,0
    jmp :recive_msg_route_request
    mov u14,u3				# got route response
    mov u15,u4
    mov u10,u0
    mov u11,u1
# debug stuff
#    mov s15,:rr_1
#    mov s14,^rr_1
#    call :debug
# e o d
    call :route_find
    ifneq u0,0
    jmp :recive_msg
    mov u0,u10				# no such route entry
    mov u1,u11
    call :route_find_target
    ifeq u0,0
    jmp :recv_msg_new_route
    mov u1,u0				# but we've got stream to this vs
    add u1,4
    ifeq *u1,0
    jmp :recv_msg_stream_target		# no target route yet..
    ifneq *u1,u10
    jmp :recv_msg_route_mismatch	# hmm.. something is wrong here...
    add u1,1
    ifeq *u1,u11
    jmp :recive_msg	
:recv_msg_route_mismatch
    mov u0,:recive_msg_route_response_warning
    mov u1,^recive_msg_route_response_warning
    syscall $IO_PUTSTRING
    jmp :recive_msg
:recv_msg_stream_target			
#debug stuff
#    mov s15,:rr_6
#    mov s14,^rr_6
#    call :debug
# e o d
    mov *u1,u14				# netaddr -> 
    add u1,1
    mov *u1,u15				# netmask ->
    add u1,1
    mov *u1,u10				# fill up info about peer
    add u1,1
    mov *u1,u11
    call :touch_structure
    jmp :recive_msg
:recv_msg_new_route
#debug stuff
#    mov s15,:rr_5
#    mov s14,^rr_5
#    call :debug
# e o d
    call :route_new
    call :route_link
    call :touch_structure
    mov u1,u0
    add u1,4
    mov *u1,u14				# netaddr -> 
    add u1,1
    mov *u1,u15				# netmask ->
    add u1,1
    mov *u1,u10				# vcpu ->
    add u1,1
    mov *u1,u11				# vs ->
    add u1,1
    mov *u1,ROUTE_FLAG_REQ		# 1 -> flags
    add u1,1
    
    mov u13,u0
    mov u12,u1

    mov u0,IPC_FLAG_NONBLOCK
    mov s0,u10
    mov s1,u11
    mov u1,DVR_IPCREG
    onfail :onfail_send_stream_request
    syscall $IPC_STREAM_REQ
    nofail
    mov u1,u12
    ifeq u14,0
    jmp :drop_route
    mov *u1,u0				# req_id ->
    jmp :recive_msg
:drop_route
    mov u0,u13
    call :route_unlink
    call :route_done
    jmp :recive_msg

:recive_msg_route_request		
#debug stuff
#    mov s15,:rr_2
#    mov s14,^rr_2
#    call :debug
# e o d
    mov u4,*:my_netmask
    and u4,u3
    ifneq u4,*:my_netaddr
    jmp :recive_msg
    mov s0,u0				# notify sender that we know route
    mov s1,u1
    mov u1,u2
    mov u2,*:my_netaddr
    mov u3,*:my_netmask
    mov u0,IPC_FLAG_NONBLOCK
    onfail :onfail_recive_msg_route_request
    syscall $IPC_MSG_SEND
    nofail
#debug stuff
#    mov s15,:rr_3
#    mov s14,^rr_3
#    call :debug
#end debug stuff
    jmp :recive_msg



:onfail_recive_msg_route_request
    mov u0,:recive_msg_route_request_warning
    mov u1,^recive_msg_route_request_warning
    syscall $IO_PUTSTRING
    ret 1
    
:onfail_send_stream_request
    mov u0,:send_stream_request_warning
    mov u1,^send_stream_request_warning
    syscall $IO_PUTSTRING
    mov u14,0
    ret 1
# DONE

.DATA
:sa_1
    "--- Sent stream ack\n"
:isrh_1
    "--- in stream requests handler\n"
.CODE

:ipc_init
    mov u0,DVR_IPCREG
    syscall $IPC_REGISTER
    ret 1

:ipc_stream_requests_handler
    mov u0,IPC_FLAG_NONBLOCK
    syscall $IPC_STREAM_QUEUE		# die on any errors
    ifneq s0,IPC_EOK
    jmp :ipc_stream_requests_handler_done
# debug
#    mov s15,:isrh_1
#    mov s14,^isrh_1
#    call :debug
# eod
    mov u15,u0
    mov u14,u1
    mov u12,u3
    ifneq u2,DVR_IPCREG			# bad peer
    jmp :ipc_stream_requests_handler_nack
    mov u0,u15
    mov u1,u14
    call :route_find_target
    ifneq u0,0				# we alredy got this route entry..
    jmp :ipc_stream_requests_handler_nack

    mov u0,IPC_FLAG_NONBLOCK
    mov u1,u12
    onfail :ignore
    syscall $IPC_STREAM_ACK
    nofail
    ifneq s0,IPC_EOK
    jmp :ipc_stream_requests_handler
    mov u12,u0

#debug stuff
#    mov s15,:sa_1
#    mov s14,^sa_1
#    call :debug
#end debug stuff

    call :route_new
    call :route_link
    call :touch_structure
    mov u1,u0
    add u1,4
    mov *u1,0				# netaddr 0
    add u1,1
    mov *u1,0				# netmask 0
    add u1,1
    mov *u1,u15				# vcpu
    add u1,1
    mov *u1,u14				# vs
    add u1,1
    mov *u1,ROUTE_FLAG_STREAM		# flags
    add u1,2
    mov *u1,u12				# stream id
    add u1,1
    mov *u1,0				# in packet
    add u1,3
    mov *u1,0				# out packet
    jmp :ipc_stream_requests_handler
:ipc_stream_requests_handler_nack
    mov u0,u12
    onfail :ignore
    syscall $IPC_STREAM_NACK
    nofail
    jmp :ipc_stream_requests_handler
:ipc_stream_requests_handler_done
    ret 1



:ignore
    mov s0,-1
    ret 1
# DONE 


############################################################################
# endianess in () out u0 (0 = le, 1 = be) changes ()
.DATA
:endianess_test
    "1234"
:endianess_warning
    "WARNING: Your system is neither big-endian nor little-endian.\n"

.CODE
:endianess
    mov u0,*:endianess_test
    ifeq u0,0x31323334
    jmp :endianess_be
    ifeq u0,0x34333231
    jmp :endianess_le
    mov u0,:endianess_warning
    mov u1,^endianess_warning
    syscall $IO_PUTSTRING
    halt
:endianess_le
    mov u0,0
    mov *:endianess_current,u0
    ret 1
:endianess_be
    mov u0,1
    mov *:endianess_current,u0
    ret 1


#######################################################################
# bswab	  in (u0) out (u0) changes (nothing)
# bswab_w in (u0) out (u0) changes (nothing)

:bswab
    ifeq *:endianess_current,0
    jmp :bswab_le
    ret 1

:bswab_w
    ifeq *:endianess_current,0
    jmp :bswab_le_w
    ret 1

:bswab_b
    ifeq *:endianess_current,0
    jmp :bswab_le_b
    ret 1

.DATA
:bswab_le_t
    0
:bswab_le_o
    0
.CODE
:bswab_le
    mov *:bswab_le_t,u0
    movb3 u0,*:bswab_le_t
    mov *:bswab_le_o,u0
    movb2 u0,*:bswab_le_t
    mul u0,0x100
    add *:bswab_le_o,u0
    movb1 u0,*:bswab_le_t
    mul u0,0x10000
    add *:bswab_le_o,u0
    movb0 u0,*:bswab_le_t
    mul u0,0x1000000
    add u0,*:bswab_le_o
    ret 1

:bswab_le_w
    mov *:bswab_le_t,u0
    movb1 *:bswab_le_o,u0
    and u0,0xff
    mul u0,0x100
    add u0,*:bswab_le_o
    ret 1

:bswab_le_b
    mov *:bswab_le_t,u0
    div u0,0x10
    mov *:bswab_le_o,u0
    mov u0,*:bswab_le_t
    and u0,0xf
    mul u0,0x10
    add u0,*:bswab_le_o
    ret 1
# TODO
# in_network_handler bigendian

# domain 3 = low network
.DATA
:interface_in
    0
:interface_out
    0
:interface_mac
    "123456"
:init_ether_error
    "[ERROR] Couldn't initialize low network subsystem.\n"
.CODE

:init_ether_be
    jmp :init_ether
:init_ether_le
    mov u0,*:my_ip
    call :bswab_le
    mov *:my_ip,u0
    mov u0,*:my_netaddr
    call :bswab_le
    mov *:my_netaddr,u0
    mov u0,*:my_netmask
    call :bswab_le
    mov *:my_netmask,u0
:init_ether
    onfail :init_ether_onfail
    mov u0,:interface_name
    mov u1,^interface_name
    syscall $LOW_NET_INITDEV
    mov *:interface_in,s0
    syscall $LOW_NET_RAW
    mov *:interface_out,s0
    mov u0,:interface_name
    mov u1,^interface_name
    syscall $LOW_NET_GETHWADDR
    mul u0,0x1000000
    mul u1,0x10000
    add u0,u1
    mul u2,0x100
    add u0,u2
    add u0,u3
    call :bswab
    mov u1,:interface_mac
    mov *u1,u0
    add u1,1    
    mul u4,0x1000000
    mul u5,0x10000
    add u4,u5
    mov u0,u4
    call :bswab
    mov *u1,u0

    nofail
    ret 1
    
:init_ether_onfail
    mov u0,:init_ether_error
    mov u1,^init_ether_error
    syscall $IO_PUTSTRING
    halt
    

#########################################################################
# calculate_checksum -- in (u0,u1) -- out (u0) -- changes ()
.DATA
:calculate_checksum_temp
    0
:calculate_checksum_temp2
    0
:calculate_checksum_temp3
    0
.CODE
:calculate_checksum
    mov *:calculate_checksum_temp,u10
    mov *:calculate_checksum_temp2,u11    
    mov *:calculate_checksum_temp3,s0
    mov u10,u0
    mov s0,u1
    sub s0,1
    mov u11,0
:chksum_loop
    movw0 u0,*u10
    add u11,u0
    movw1 u0,*u10
    add u11,u0
    add u10,1
    loop :chksum_loop
    mov u0,u11
    and u11,0xffff
    div u0,0x10000
    add u11,u0
    mov u0,u11
    and u11,0xffff
    div u0,0x10000
    add u11,u0
    mov u0,-1
    sub u0,u11
    and u0,0xffff
    mov u10,*:calculate_checksum_temp
    mov u11,*:calculate_checksum_temp2    
    mov s0,*:calculate_checksum_temp3
    ret 1

##############################################################################
# le version
.DATA
:raw_bucket
    0 repeat 379
:raw_bucket_len
    0
.CODE
:in_network_handler
    ifeq *:packet_free,0			# no free buckets... 
    ret 1
    mov u0,*:interface_in
    mov u1,:raw_bucket
    mov u2,1514
    syscall $LOW_NET_RECV
    ifneq s1,1
    ret 1
    mov *:raw_bucket_len,s0
    mov u0,:raw_bucket			# check if our mack in src field
    mov u1,6
    mov u2,:interface_mac
    mov u3,0
    mov u4,6
    syscall $MEM_STRCMP
    ifeq u0,0
    jmp :in_network_handler

    mov u0,:raw_bucket
    add u0,3
    movw0 u0,*u0
    call :bswab_w
    ifneq u0,0x800			# its not IP packet!
    jmp :in_network_handler
    
    mov u0,:raw_bucket
    mov u1,0
    mov u2,:raw_bucket
    mov u3,14
    mov u4,*:raw_bucket_len
    sub u4,14
    mov *:raw_bucket_len,u4
    syscall $MEM_STRCPY			# let us skip ether header
    call :check_ip_packet
    jmp :in_network_handler


:check_ip_packet
    ifbel *:raw_bucket_len,20
    jmp :bad_or_done
    mov u15,:raw_bucket
    movb0 u0,*u15
    call :bswab_b		# to make it endian independent
    mov u1,u0			
    and u0,0xf
    div u1,0x10
    ifneq u0,0x4
    jmp :bad_or_done		# bad ip version
    ifbel u1,0x5
    jmp :bad_or_done		# invalid header len
    mul u1,4
    ifabo u1,*:raw_bucket_len
    jmp :bad_or_done		# too short eth frame...
    div u1,4
    movw1 u0,*u15
    call :bswab_w
    ifbel *:raw_bucket_len,u0	# again too short 
    jmp :bad_or_done
    mov *:raw_bucket_len,u0	# cut to size..
    mov u4,u15
    add u4,2
    ifeq *:endianess,1
    jmp :part_be
    mov u2,*u4
    mov u3,u2
    mov u5,u2
    and u3,0xffff
    and u2,0xffff0000
    mov *u4,u3
    mov u0,u15
    call :calculate_checksum
    mul u0,0x10000
    ifneq u0,u2			
    jmp :bad_or_done		# checksum failure
    and u5,0xff
    and u3,0xff00
    ifeq u5,1
    jmp :bad_or_done
    sub u5,1
    add u3,u5
    mov *u4,u3
    jmp :part_done
:part_be
    mov u2,*u4
    mov u3,u2
    mov u5,u2
    and u3,0xffff0000
    and u2,0xffff
    mov *u4,u3
    mov u0,u15
    call :calculate_checksum
    ifneq u0,u2
    jmp :bad_or_done
    and u5,0xff000000
    and u3,0xff0000
    ifeq u5,0x1000000
    jmp :bad_or_done
    sub u5,0x1000000
    add u3,u5
    mov *u4,u3
    
:part_done
    add u4,1
    mov u0,*u4
    and u0,*:my_netmask
    ifneq u0,*:my_netaddr
    jmp :bad_or_done		# packet from outher space... (CHECKIT)
    add u4,1
    mov u5,*u4
    mov u0,u5
    and u0,*:my_netmask
    ifeq u0,*:my_netaddr
    jmp :bad_or_done		# local target.. borink

    call :packet_new		# oh there is one free packet... i'm sure
    ifeq u0,0
    ret 1
    call :packet_in_link
    call :touch_structure
    mov u13,u0
    add u0,4
    mov *u0,*:raw_bucket_len
    add *u0,4
    add u0,1
    mov *u0,u5
    add u0,1
    mov u3,u0
    mov u0,*:raw_bucket_len
    call :bswab
    mov *u3,u0
    add u3,1
    mov u0,u3
    mov u1,0
    mov u2,u15
    mov u3,0
    mov u4,*:raw_bucket_len
    syscall $MEM_STRCPY			# copy copy to bucket...
    mov u14,u5
    call :route_find    
    ifeq u0,0
    call :send_route_request

# debug stuff
#.DATA
#:debug_srr
#    "--- got good IP packet\n"
#.CODE
#    mov s15,:debug_srr
#    mov s14,^debug_srr
#    call :debug
# e o d 
					# packet is ok and linked
:bad_or_done
    ret 1

##########################################################################
# send_ttl_expired: in (u15,u14,u1) out () changes (all)
.DATA
:temporary_ip_bucket
    0 repeat 5
:temporary_icmp_bucket
    0 repeat 370
.CODE
:send_ttl_expired
# tworzymy naglowek IP
    mov u0,:temporary_ip_bucket
    mov *u0,0x00000054          # ver 4 ihl 5 tos 0 len ??
    add u0,1
    mov *u0,0                   # id 0 flags 0 offset 0
    add u0,1
    mov *u0,0x00000140          # ttl 64 proto 1 (icmp) checksum ??
    add u0,1
    mov *u0,*:my_ip            # we're the sender
    add u0,1
    mov u2,u15
    add u2,3
    mov *u0,*u2                 # and they're gonna listen
# teraz liczymy czeksume ip
    mov u0,:temporary_ip_bucket
    mov u2,u0
    mov u10,u1
    mov u1,5
    call :calculate_checksum
    call :bswab_le
    mul u0,0x10000
    add u2,2
    add *u2,u0
# doklejamy naglowek ICMP
    mov u0,:temporary_icmp_bucket
    mov *u0,0000000b            # type 11, code 0 checksum ??
    add u0,1
    mov *u0,0                   # unused 0
    add u0,1

# teraz doklejamy tego no... naglowek pakietu plus 2 dwordy
    mov u4,u10
    add u4,2
    mul u4,4
    mov u3,0
    mov u2,u15
    mov u1,0
    syscall $MEM_STRCPY
    div u4,4
    add u4,2
    mov u0,:temporary_icmp_bucket
    mov u1,u4
    call :calculate_checksum
    mul u0,0x10000
    add *:temporary_icmp_bucket,u0
    mov u0,5
    add u0,u4
    mov u2,u0
    call :bswab_le
    add *:temporary_ip_bucket,u0
    mov u1,:temporary_ip_bucket                 # (TODO)
    mov u0,*:interface_out
    syscall $LOW_NET_SEND
    ret 1


###########################################################################
# send_packets	in () out () change (a lot)

.DATA
:sp_1
    "--- in send packets\n"
.CODE

:send_packets
    mov u1,*:out_packet_first
    ifeq u1,0
    ret 1
#debug stuff
#    mov s15,:sp_1
#    mov s14,^sp_1
#    call :debug
#end of debug stuff
    add u1,6
    mov u0,*u1
    call :bswab
    mov u2,u0
    add u1,1
    mov u0,*:interface_out
    syscall $LOW_NET_SEND
    ifeq s1,1
    jmp :send_packets_continue
    ifeq s2,u2
    jmp :just_done
:unlink_and_done
    mov u0,*:out_packet_first	
    call :packet_out_unlink
    call :packet_done
:just_done    
    ret 1

:send_packets_continue
    mov u0,*:out_packet_first		# unlink and repeat
    call :packet_out_unlink
    call :packet_done
    jmp :send_packets


