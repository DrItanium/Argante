  AHLL translator has been written in a hurry. Our goal was to introduce
  a good high-level language for effective programming before releasing
  Argante 1.0.  Unfortunately, writing good and usable HLL compiler,
  and, what's probably the most important, implementing a good language,
  is a complex task. I spent several sleepless nights working on it
  myself, and results are not shocking.

  Yes, you're able to write high-level programs in AHLL, but current
  implementation is far, far away from the thing I wanted to achieve. It
  will change in future AOS releases, but for now we cannot delay the
  first release just because AHLL is not perfect.

  So, the first thing you should ABSOLUTELY understand: AHLL is *NOT* AN
  INTEGRAL PART OF ARGANTE OS. What do I mean? Well, it's an example on
  how it can be done, and a useful tool, but nothing more. You can
  implement any other language (or, better, its reasonable subset) -- my
  favourite replacement for AHLL is a well-chosen subset of Ada. If
  you're interested in it, let me know.

  OK. AHLL code is really dirty, obfuscated and ugly. It's also buggy as
  hell, full of buffer overflows and so on - just deal with it. It should be
  and will be completely rewritten - now all I could do is to make it work.
  I cannot guarantee it will produce usable executables in all cases, but
  I hope so :))) Code generated by AHLL is highly ineffective, and there
  are several restrictions, like:

  - Recurrent procedure calls are deadly - YOU SHOULD NOT DO THAT FOR NOW;
    current version of AHLL is broken (and should be redesigned), so if you
    enter procedure A once, and then, without leaving it, call A again,
    and finally, this second call will be finished, you'll notice A
    parameters / locals were modified by this second call; that's because
    AHLL does NOT support dynamically allocated call parameters / local
    functions stack. If you really need to do that, use parameterless (or
    called in constant way) procedures, and implement simple dynamic
    allocation. In any other case, you should not use A's local parameters /
    variables after calling A within A ;>

  - When accessing structures and arrays, only following conventions are
    available: table[simple_variable], str_table[simple_variable].field,
    structure.field. So you cannot nest: table[table[table[n]].field], and
    you cannot directly access arrays inside structures (eg. str.field[nn]).
    If you need such access, you should use pointer assignments, eg:

    pointer_to_array_copy := str.field;
    ...and now you can access pointer_to_array_copy[nn];

  - There's no complex arithmetics! Only one operator per expression. Also,
    there's no assign-when-calling-function-when-comparing-to... but I'm
    in doubt if such C conventions are good at all ;>

  - Floating point arithmetics is untouched.

  - There are no "helper" statements like for - you have while and loop
    instead, which are equivalent.

  I know it sucks, but I have no time to work on it right now. Please help
  us creating better HLL environment!

  Now, let's talk about Another-Hard-to-Learn-Language and its the
  precompiler...  If you're familiar with C, you'll have no problem with
  understanding code constructions - but, in AHLL, you don't have, for
  example, C pointer arithmetics :> Following description is only a
  rough draft, but should be enough to catch the idea.

  AHLL is case insensitive.

  1) Precompiler
  ~~~~~~~~~~~~~~

  #include "filename"	- this directive will include file at current
                            position; there are some standard include files
                            in hll/include directory.

  #define SYMBOL value    - SYMBOL will be replaced with value - no macros
                            are supported, unlike in C

  #compiler ...           - following statement will be passed as-is
                            to the AGTC RSIS compiler, useful for ! directives.

  #cstring name "value"   - specific construction to make string initialization
                            easier; it has been introduced due to weak
                            AHLL implementation in AOS 1.0; it will be
                            described later.

  2) Type declarations
  ~~~~~~~~~~~~~~~~~~~~

  Predefined types: unsigned, signed, float.

  You can declare a new type or create a subtype. While subtype is "usable" with
  other similar subtypes, types cannot be mixed without implicit conversion.
  This mechanism is more or less similar to Ada, except in AHLL shipped with
  AOS 1.0 it isn't really accurate ;P

  Type declaration:

    [sub]type new_type_name is base_type;

    (subtype can be applied only to simple types, not to arrays, structures
    and so on)

  Arrays:

    type new_type_name is array start .. stop of base_type;

  Bytechunks:

    type new_type_name is bytechunk start .. stop;

    Bytechunk is a packed array of bytes of specified length. For now,
    its fields cannot be accessed directly.

  Structures:

    type new_type_name is structure {
      field_name : [modifiers] type;
      field_name : [modifiers] type;
    }

    Possible modifiers: 'pointer to', 'addressable'. "Pointing" variables
    might be used in the same way as normal variables (there's no difference
    in calling method or so), except they're "mirroring" base objects, not
    having their own memory allocated. Only "addressable" variable can be
    assigned to pointer.

    For pointer examples, see Examples/AHLL/ptrs.ahl - pretty good.

  Complex type declarations are not allowed. For example, you cannot use:

    type new_type is array 1 .. 20 of structure { ... };

  You have to split such declaration into two typedefs.

  Types can be declared only at a high-level (no local type declarations are
  allowed).


  3) Variable declarations and initializers
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Variable declarations may appear in global or local {} scope. In both
  cases, the format is as follows:

  var_name : [modifier] type_name [ := initializer ];

  For modifiers, see paragraph 2. An initializer may be an immediate value,
  a string, or a complex initializer. Initializers are not allowed for pointers.

  Complex initializer contains list of array / structure fields. No nested
  initializers are allowed (so you cannot initialize array of structures
  at once):

    var_name : type_name := {
      value_for_field1,
      value_for_field2,
      // List MUST end with ','.
    }

  To skip complex types / pointers in structure initializers, use keyword "none".


  4) Procedures
  ~~~~~~~~~~~~~

  There are no functions in Argante. A procedure can accept any number of
  parameters, and then modify these marked as "writable" - which are used
  as output data:

  procedure ProcedureName ( [writable] param1 : param1_type, [writable]
                            param2 : param2_type ... ) {

    local {
      // Local declarations
    }

    // Local code

    exception {
      // Exception code
    }
  }

  There's special, parameterless procedure, called Main, which is executed
  at the beginning (entry point). It has to be present in every program.

  Procedure calling within local code can be done as follows:

    ProcedureName ( [modifier] param1, [mod] param2, [mod] param3 );

  Allowed modifiers: convert - implicit conversion of types
                    address - address of specific variable


  5) Exception handling
  ~~~~~~~~~~~~~~~~~~~~~

  exception {} block is called if exception occurs within guard {} block
  in local code:

    guard {
      // Some commands...
    }
    // Other commands...
    exception {
      // Handler
    }

  Only an exception in guarded code will cause execution of exception {} block.
  In this block, you have to use "case" commands to handle specific
  exception numbers (see switch {} block). The differences between exception {}
  code and normal code:

    ignore		- this command will return to the point where exception
                            happened; not smart.

  'return' should be used to return to calling function, 'raise NN' should
  be used to pass the exception to high-level handlers (declared before
  calling this procedure). Exception will be passed after reaching the end
  of exception {} block as well.

  AHLL generates some exception code while doing range-checking and
  pointer validation.


  6) Conditional statements, loops, gotos
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [not] one_value { ... }       - executed if non-zero/zero
    if one_item = other_item { ... } - complex comparison
    if one_val op other_val { ... }  - simple op ( <, >, =, <>, &, <=, >=).

    while CONDITION { ... }          - where CONDITION can be the same as in
                                      "if" - repeat code while...

    loop CONDITION { ... }           - like "while", but check is done at the
                                      end of every pass.

    continue;                        - jump to the check condition of the loop

    break;                           - exit from current loop

    switch simple_value {            - well, you should know; there's no need
      case val;                        to 'break' before every next case.
        // Code
      case other_val;
        // Code
      case default;
        // Code
    }

    label:			  - local jumps
    goto label;


  7) Assignments and arithmetics
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    x := y;		- copy (can be used on complex types)

    x [op]= y;            - arithmetics (+, -, |, &, %, *, ^, /, ~)

    create x;             - assign new variable to pointer
    x := bind y;          - bind pointer to addressable variable
    destroy x;            - destroy dynamically created variable
    unbind x;             - unbind pointer

    x := {address|convert} y - see functions.

  8) Syscalls
  ~~~~~~~~~~~

    To do syscall, you should use following notation

    syscall ( SYSCALL_NAME,		- should be #defined
              u0 := some_value,
              u1 := other_value,
              // ...			- parameters to put in registers
              something_writable := s0,
              // ...			- return values
            );


  You can find some AHLL examples in Examples/AHLL subdirectory. To compile,
  you should change your working directory to hll/, and then, use ./acc or
  ./ahlt (ahlt will produce .agt file from .ahl file - so in fact it's
  the main translator; ./acc will produce .img from .ahl file - so full compilation
  will be done). On systems with /bin/bash, you can run ./acc with -e option
  (eg: ./acc -e examples/dir.ahl) to perform dead-code elimination.

  Another example you can find there is Mini-HTTP server. It's trivial, but
  effective tool :)



